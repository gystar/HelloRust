#Rust编程之道
##第二章
###1. 语句和表达式
(1). 语句分为
- 声明语句:用于声明各种语言项，可看作返回"()"
- 表达式语句：特指以分号结尾的表达式，求值结果总是会被丢弃，返回单源类型"()"
(2). 单元类型"()",只有唯一的值即为其背身，表示“没有什么特殊的价值”
(3). 名字以叹号结尾 并且可以像函数一样被调用的语句叫作宏，例如println!
(4). **代码解析特点**
- 碰到分号，继续往后执行
- 碰到语句，执行语句
- 碰到表达式，则计算表达式的值
- 如果分号后面什么都没有，则补上()
- 遇到函数，将函数的"{}"识别为块表达式。块表达式总是返回块中的最后一个表达式的值
例如：
fn main() {
    println!("Hello,guiyi！");
    pub fn answer() -> () {
        let a = 1;
        let b = 2;
        assert_eq!(sum(a, b), 3);
    }
    pub fn sum(a: i32, b: i32) -> i32 {
        a + b
    }
    answer();
}
其中answer的块表达式最后一个语句为宏判断语句，以";"结尾，则执行后，返回()
sum的块表达式最后一个语句是表达式（没有分号），计算后返回表达式的值
###2. 变量与绑定
(1). 表达式分为：
位置表达式,即描述内存位置的表达式：
- 本地变量
- 静态变量
- 解引用(*expr)
- 数组索引(expr[expr])
- 字段引用(expr.field)
- 位置表达式组合
值表达式：除了以上的均为值表达式
(2). 上下文
位置上下文：
- 赋值或者复合赋值语句左侧的操作数
- 一元引用表达式的独立操作数
- 包含隐式借用（引用）的操作数
- match 判别式或 let 绑定右侧在使用 ref 模式匹配的时候也是位置上下文。
值上下文：除了以上，均为值上下文
###3. 绑定、所有权和引用
(1). 绑定
- 不可变绑定： let a = 2;   //不可改变a的值
- 可变绑定： let **mut** a = 2；//可以改变a的值
(2). 所有权
- 当位置表达式出现在值上下文中，将会把内存地址转移(即所有权的转移)给另一个位置表达式，例如：
let place1 = "hello"; //place1为位置表达式
let other = place1;   //转移地址给other,所有权转移
- **内存地址的转移行为就是所有权的转移，称为移动(Move)语义，Rust没有GC，因为不进行复制(Copy)，而是完全靠所有权的转移来进行内存管理**
(3). 引用
- 不需要进行所有权转移的时候使用引用操作符&来直接获取表达式的存储单源地址（内存位置），使用此内存位置来进行读写：
例如：
let a = [1,2,3];
let b = &a;             //b为a的地址,使用*b来打印a的值
let mut c = vec![1,2,3];//动态数组
let mut d = &mut c;     //可变引用
d.push(4);
let e = &5;          //由于5是指表达式，在位置上下文求职，编译器会为&5创建一个临时数值
**注意：获取可变引用，必须先声明可变绑定**
- 借用：引用方式原来的绑定保留了所有权，因此引用也被称为借用
###4. 函数与闭包
(1). 应用程序的入口是main
(2). 函数的定义：
fn <fname> < (p1_name : type [,p2_name : type]...) | ()> {
    //函数定义
    ...
    //自动返回最后一个语句或者使用return提前返回
}
(3). 作用域和声明周期
- 为静态作用域，即词法作用域，由"{}"来界定，在词法分析阶段就固定下来不再改变,例如：
fn main(){
    let a = 1;
let a = 2;//变量遮蔽
{//新的作用域
    let a = 3;//声明周期在此花括号内部，不会改变外部的a的值
}
}
(4). 函数指针
- 函数作为参数：
fn f1(pf : fn(i32, i32)->i32, a : i32, b : i32)->i32{
    pf(a,b)
}
- 函数作为返回值
fn f2()-> i32{1};
fn f3()->fn->i32{f2}
(5). CTFE机制(编译时函数执行),在编译的时候能执行某些函数:需要使用nightyly版本且打开开关
(6). 闭包(匿名函数)
- 定义闭包
let out = 1;
let closure1 = |a:i32, b:i32|->i32{a+b+out};// 使用了外部变量的函数闭包
let closure2 = |i, j| i + j +out;
**注意：闭包可以捕获并使用外部的变量，而函数不行**
- 闭包作为参数
fn f1<F: Fn()->i32>(op : F)->i32{ op()};
其中F为范型，且受Fn()->i32 trait的限定
- 闭包作为返回值
fn f1()->impl Fn(i32) -> i32{
    let i = 2;
    move |j:i32|->i32{j*i} //使用move转移所有权，否在此作用域定义的闭包会被销毁成为垂悬指针                        
}
###5. 流程控制
(1). 条件表达式 == < >
if (表达式){ }else{}, 也会返回一个值，返回的值为括号中的返回值，例如：
let a = if(2 < 4){1}else{2};
(2). 循环表达式while、 loop、  for in
while(表达式){}
for n in 1..100{}
**注意：如果while或者if的条件语句（只有一个分支）只有ture，则编译器认为此语句块返回的是()，而不会判断循环体中的语句的返回类型**
(3). match表达式和模式匹配
使用模式匹配技术来实现match
let n = 42;
match n {//每种情况必须返回同样的类型
    0         => println!("1"),          //单个值匹配
    1...3     => println!("2"),          //范围匹配
    | 3| 5| 7 => println!("3");          //多值匹配
    n @ 10    => println!("{}", n);      //绑定模式：绑定10的值给n，供右边的处理表达式使用
    _         => println!("0"),          //使用通配符来处理剩下的情况
}
(4). while let 和 if let
let mut v = vec![1,2,3,4,5];
while(let Some(x) = v.pop()){
    println!("{}", x);
}
let b1 = true;
let mut v1 = 0;
if(let true = b1){v1 = 2;}